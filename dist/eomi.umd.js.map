{"version":3,"file":"eomi.umd.js","sources":["../src/conjugation.ts","../src/analyzer.ts"],"sourcesContent":["/* Utilities */\n\n/**\n * 초성, 중성, 종성에 해당하는 인덱스로 한글 음절을 조합한다.\n * @param x 초성 (0-18), 중성 (0-20), 종성 (0-27)으로 이루어진 정수 배열\n * @returns 조합된 한글 음절\n */\nfunction assembleSyllable(x: number[]): string {\n  const codepoint = x[0] * 588 + x[1] * 28 + x[2] + 0xac00;\n  return String.fromCharCode(codepoint);\n}\n\n/**\n * 문자열의 마지막 음절을 초성, 중성, 종성에 해당하는 인덱스로 분해한다.\n * @param x 분해하고자 하는 한글 음절로 끝나는 문자열.\n * @returns 초성 (0-18), 중성 (0-20), 종성 (0-27)으로 이루어진 정수 배열.\n */\nfunction disassembleSyllable(x: string): number[] {\n  const codepoint = x.charCodeAt(x.length - 1) - 0xac00;\n  const choseong = (codepoint / 588) | 0;\n  const jungseong = ((codepoint % 588) / 28) | 0;\n  const jongseong = codepoint % 28;\n  return [choseong, jungseong, jongseong];\n}\n\nconst BATCHIM_TABLE = \"ㄱㄲㄳㄴㄵㄶㄷㄹㄺㄻㄼㄽㄾㄿㅀㅁㅂㅄㅅㅆㅇㅈㅊㅋㅌㅍㅎ\";\nfunction getBatchim(x: string): string {\n  const idx = disassembleSyllable(x)[2];\n  return idx === 0 ? \"\" : BATCHIM_TABLE[idx - 1];\n}\n\nfunction startsWithSyllable(x: string): boolean {\n  return \"가\" <= x[0] && x[0] <= \"힣\";\n}\n\n/**\n * 두 한글 문자열을 결합한다.\n * @param x 결합할 앞 문자열.\n * @param y 결합할 뒤 문자열. 한글 음절로 시작하지 않을 수 있다.\n * @returns 결합된 문자열.\n */\nfunction concatHangeul(x: string, y: string): string {\n  const err = new Error(`Cannot concatenate '${x}' and '${y}'`);\n  if (!x || !y || startsWithSyllable(y)) return x + y;\n  const table = [\n    ,\n    ,\n    \"ㄱㄱ\",\n    \"ㄱㅅ\",\n    ,\n    \"ㄴㅈ\",\n    \"ㄴㅎ\",\n    ,\n    ,\n    \"ㄹㄱ\",\n    \"ㄹㅁ\",\n    \"ㄹㅂ\",\n    \"ㄹㅅ\",\n    \"ㄹㅌ\",\n    \"ㄹㅍ\",\n    \"ㄹㅎ\",\n    ,\n    ,\n    \"ㅂㅅ\",\n    ,\n    \"ㅅㅅ\",\n  ];\n  let newBatchim = table.indexOf(getBatchim(x) + y[0]);\n  if (newBatchim === -1) {\n    if (getBatchim(x)) throw err;\n    newBatchim = BATCHIM_TABLE.indexOf(y[0]) + 1;\n    if (newBatchim === 0) throw err;\n  }\n\n  let merged: number[] = disassembleSyllable(x);\n  merged[2] = newBatchim;\n  return x.slice(0, -1) + assembleSyllable(merged) + y.slice(1);\n}\n\n/* Main Classes */\n\n/** 한국어 용언 클래스. */\nclass Yongeon {\n  hada: string;\n  hae: string;\n  hani: string;\n  hamyeon: string;\n  batchim: string;\n\n  constructor(hada: string, hae?: string, hani?: string) {\n    this.hada = hada.slice(0, -1);\n    this.batchim = getBatchim(this.hada);\n\n    this.hae = hae || this.recoverHae();\n    this.hani = hani ? hani.slice(0, -1) : this.recoverHani();\n    this.hamyeon = this.batchim === \"ㄹ\" ? this.hada : this.hani;\n  }\n\n  /**\n   * 어미를 받아 활용합니다.\n   * 인수로는 어미 하나를 받거나 문자열 두 개를 받아 어미를 만듭니다.\n   */\n  _(eomi: Eomi | string, eomiAfterBatchim?: string): string {\n    if (!(eomi instanceof Eomi)) eomi = new Eomi(eomi, eomiAfterBatchim);\n    else if (eomiAfterBatchim != null)\n      throw Error(\n        \"If the first argument is a proper Eomi, only one argument should be given.\"\n      );\n\n    return eomi.after(this);\n  }\n\n  recoverHae(): string {\n    let jamos = disassembleSyllable(this.hada);\n    if (!this.batchim) {\n      if (jamos[1] === 0 || jamos[1] === 4) {\n        return this.hada; // ㅏ, ㅓ\n      } else if (jamos[1] === 18) {\n        jamos[1] = 4; // ㅡ -> ㅓ\n        return this.hada.slice(0, -1) + assembleSyllable(jamos);\n      }\n    }\n    return this.hada + (jamos[1] === 0 || jamos[1] === 8 ? \"아\" : \"어\"); // ㅏ, ㅗ\n  }\n\n  recoverHani(): string {\n    let jamos = disassembleSyllable(this.hada);\n    if (this.batchim === \"ㄹ\") {\n      // ㄹ 탈락\n      jamos[2] = 0;\n      return this.hada.slice(0, -1) + assembleSyllable(jamos);\n    }\n\n    const haeLast = this.hae.slice(-1);\n    if (\"아어\".indexOf(haeLast) !== -1) {\n      // 받침 있는 규칙 | ㄷ ㅅ 불규칙\n      return this.hae.slice(0, -1) + (this.batchim && \"으\");\n    } else if (\"와워\".indexOf(haeLast) !== -1) {\n      // ㅂ 불규칙\n      return this.hae.slice(0, -1) + \"우\";\n    } else if (this.batchim === \"ㅎ\") {\n      // ㅎ 불규칙\n      jamos[2] = 0;\n      return this.hada.slice(0, -1) + assembleSyllable(jamos);\n    }\n    return this.hada; // 받침 없는 규칙 | 르, 러, 우, 여 불규칙\n  }\n\n  valueOf(): string {\n    return this.hada + \"다\";\n  }\n}\n\nconst enum EomiType {\n  DIRECT = \"\",\n  A_EO = \"(아/어)\",\n  EU = \"(으)\",\n}\n\n/** 어미 활용을 구현한 클래스. */\nclass EomiUnit {\n  eomiType: EomiType;\n  body: string;\n  dropRieul: boolean;\n\n  constructor(eomi: string) {\n    const err = new Error(`Cannot parse given string ${eomi} to EomiUnit`);\n    if (eomi[0] === \"-\") eomi = eomi.slice(1);\n\n    const infTest = eomi.match(\n      /^[(]?([아-앟어-엏])(?:[/]([아-앟어-엏]))?[)]?(.*)$/\n    );\n    const seqTest = eomi.match(/^[(]?([으-읗])[)]?(.*)$/);\n    const batchimTest = eomi.match(/^([ㄱ-ㅎ].*)$/);\n\n    if (infTest !== null) {\n      const [, med1, med2, rest] = infTest;\n      if (med2 && getBatchim(med1) !== getBatchim(med2)) throw err;\n      this.body = getBatchim(med1) + rest;\n      this.eomiType = EomiType.A_EO;\n    } else if (seqTest !== null) {\n      const [, med, rest] = seqTest;\n      this.body = getBatchim(med) + rest;\n      this.eomiType = EomiType.EU;\n    } else if (batchimTest !== null) {\n      this.body = batchimTest[1];\n      this.eomiType = EomiType.EU;\n    } else {\n      this.body = eomi;\n      this.eomiType = EomiType.DIRECT;\n    }\n\n    if (startsWithSyllable(this.body)) {\n      const choseong = ((this.body.charCodeAt(0) - 0xac00) / 588) | 0;\n      this.dropRieul = [2, 9, 11].indexOf(choseong) !== -1; // [ㄴ, ㅅ, ㅇ]\n    } else {\n      this.dropRieul = \"ㄴㄹㅂ\".indexOf(this.body[0]) !== -1;\n    }\n  }\n\n  /** 용언을 받아 활용합니다. */\n  after(yongeon: Yongeon): string {\n    let stem: string = yongeon.hada;\n    if (this.eomiType === EomiType.A_EO) {\n      stem = yongeon.hae;\n    } else if (this.eomiType === EomiType.EU) {\n      stem = this.dropRieul ? yongeon.hani : yongeon.hamyeon;\n    } else if (this.dropRieul && yongeon.batchim === \"ㄹ\") {\n      stem = yongeon.hani;\n    }\n    return concatHangeul(stem, this.body);\n  }\n\n  valueOf(): string {\n    return \"-\" + this.eomiType + this.body;\n  }\n}\n\n/** 한국어 어미 클래스. */\nclass Eomi {\n  eomi: EomiUnit;\n  eomiAfterBatchim?: EomiUnit;\n  constructor(eomi: EomiUnit | string, eomiAfterBatchim?: EomiUnit | string) {\n    if (typeof eomi === \"string\") eomi = new EomiUnit(eomi);\n    if (typeof eomiAfterBatchim === \"string\")\n      eomiAfterBatchim = new EomiUnit(eomiAfterBatchim);\n    this.eomi = eomi;\n    this.eomiAfterBatchim = eomiAfterBatchim;\n  }\n\n  /** 용언을 받아 활용합니다. */\n  after(yongeon: Yongeon): string {\n    let eomi = this.eomi;\n    if (this.eomiAfterBatchim != null && yongeon.batchim) {\n      if (yongeon.batchim !== \"ㄹ\" || !eomi.dropRieul)\n        eomi = this.eomiAfterBatchim;\n    }\n    return eomi.after(yongeon);\n  }\n\n  valueOf(): string {\n    const after = this.eomiAfterBatchim;\n    return this.eomi + (after != null ? \"/\" + after : \"\");\n  }\n}\n\nexport { Yongeon, Eomi, EomiType };\n","import { Yongeon, Eomi, EomiType } from \"./conjugation\";\n\n/* Trie */\n\ntype TrieNode<T> = { values?: T[]; children?: Map<string, TrieNode<T>> };\n\nclass Trie<T> {\n  root: TrieNode<T>;\n  constructor() {\n    this.root = {};\n  }\n\n  get(key: string): T[] {\n    let node = this.root;\n    for (let k of key) {\n      if (!node.children) return []\n      let child = node.children.get(k);\n      if (!child) return [];\n      node = child;\n    }\n    return node.values || [];\n  }\n\n  set(key: string, value: T): void {\n    let node = this.root;\n    for (let k of key) {\n      if (!node.children) node.children = new Map();\n      let child = node.children.get(k);\n      if (!child) {\n        child = {};\n        node.children.set(k, child);\n      }\n      node = child;\n    }\n    if (!node.values) node.values = [value];\n    else node.values.push(value);\n  }\n\n  /**\n   * Searches for all strings found in Trie that are the prefixes of `key`.\n   * @param key A string to search for prefixes\n   * @returns A list of pairs of values and the suffix remaining after the prefix.\n   */\n  allPrefixes(key: string): [T[], string][] {\n    let results: [T[], string][] = [];\n    let node = this.root;\n    for (let i = 0; i < key.length; i++) {\n      if (!node.children) break\n      let child = node.children.get(key[i]);\n      if (!child) break;\n      if (child.values && child.values.length) results.push([child.values, key.slice(i + 1)]);\n      node = child;\n    }\n    return results;\n  }\n}\n\n/* Analyzer */\n\n/**\n * 호환용 한글 자모 중 자음을 한글 자모 중 종성으로 변환합니다.\n * @param x 길이가 1인 문자열.\n * @returns 변환된 문자열. 해당되지 않으면 그대로 돌려받습니다.\n */\nfunction compatToJongseong(x: string) {\n  if (x < \"ㄱ\" || \"ㅎ\" < x) return x;\n  const skip = [\"ㄸ\", \"ㅃ\", \"ㅉ\"];\n  if (skip.indexOf(x[0]) !== -1) return x;\n\n  let codepoint = x.charCodeAt(0) - \"ㄱ\".charCodeAt(0);\n  skip.forEach((c) => (codepoint -= x > c ? 1 : 0));\n  return String.fromCharCode(codepoint + 0x11a8);\n}\n\n/**\n * 한글 문자열을 자모로 분리합니다.\n * @param x 한글 문자열. 음절 또는 자모로 구성됩니다.\n */\nfunction N(x: string) {\n  return x.split(\"\").map(compatToJongseong).join(\"\").normalize(\"NFD\");\n}\n\ntype YongeonForm = {\n  yongeon: Yongeon;\n  eomiType: EomiType | string;\n  dropRieul?: boolean;\n};\ntype EomiRecord = { eomi: Eomi; eomiType: EomiType; dropRieul: boolean };\n\n/** 용언의 활용형을 어근과 어미로 분리하는 클래스. */\nclass Analyzer {\n  yongeons: Trie<YongeonForm>;\n  eomis: Map<string, EomiRecord[]>;\n  constructor(yongeons: Yongeon[], eomis: Eomi[]) {\n    this.yongeons = new Trie();\n    yongeons.forEach((yongeon) => this.addYongeon(yongeon));\n\n    this.eomis = new Map();\n    eomis.forEach((eomi) => this.addEomi(eomi));\n  }\n\n  addYongeon(yongeon: Yongeon): void {\n    let dropRieul = yongeon.batchim === \"ㄹ\" ? false : undefined;\n    this.yongeons.set(N(yongeon.hada), {\n      yongeon,\n      eomiType: \"\",\n      dropRieul,\n    });\n    this.yongeons.set(N(yongeon.hae), { yongeon, eomiType: \"(아/어)\" });\n    this.yongeons.set(N(yongeon.hamyeon), {\n      yongeon,\n      eomiType: \"(으)\",\n      dropRieul,\n    });\n    if (yongeon.batchim === \"ㄹ\") {\n      this.yongeons.set(N(yongeon.hani), {\n        yongeon,\n        eomiType: \"\",\n        dropRieul: true,\n      });\n      this.yongeons.set(N(yongeon.hani), {\n        yongeon,\n        eomiType: \"(으)\",\n        dropRieul: true,\n      });\n    }\n  }\n\n  addEomi(eomi: Eomi): void {\n    this.addEomiUnit(N(eomi.eomi.body), {\n      eomi,\n      eomiType: eomi.eomi.eomiType,\n      dropRieul: eomi.eomi.dropRieul,\n    });\n    if (eomi.eomiAfterBatchim) {\n      this.addEomiUnit(N(eomi.eomiAfterBatchim.body), {\n        eomi,\n        eomiType: eomi.eomiAfterBatchim.eomiType,\n        dropRieul: eomi.eomiAfterBatchim.dropRieul,\n      });\n    }\n  }\n\n  addEomiUnit(key: string, value: EomiRecord): void {\n    let dest = this.eomis.get(key);\n    if (dest) dest.push(value);\n    else this.eomis.set(key, [value]);\n  }\n\n  /** 용언의 활용형을 분석해 어근 및 어미쌍의 배열을 내놓습니다. */\n  analyze(target: string): [Yongeon, Eomi][] {\n    let results: [Yongeon, Eomi][] = [];\n    for (let [forms, suffix] of this.yongeons.allPrefixes(N(target))) {\n      for (let { eomi, eomiType, dropRieul } of this.eomis.get(suffix) || []) {\n        for (let form of forms) {\n          if (eomiType !== form.eomiType) continue;\n          if (form.dropRieul != null && dropRieul !== form.dropRieul) continue;\n          results.push([form.yongeon, eomi]);\n        }\n      }\n    }\n    return results;\n  }\n}\n\nexport { Analyzer };\n"],"names":["assembleSyllable","x","String","fromCharCode","disassembleSyllable","codepoint","charCodeAt","length","getBatchim","idx","startsWithSyllable","Yongeon","EomiType","hada","hae","hani","this","slice","batchim","recoverHae","recoverHani","hamyeon","_","eomi","eomiAfterBatchim","Eomi","Error","after","jamos","haeLast","indexOf","valueOf","EomiUnit","err","infTest","match","seqTest","batchimTest","med1","med2","rest","body","eomiType","A_EO","EU","DIRECT","choseong","dropRieul","yongeon","stem","y","newBatchim","merged","concatHangeul","Trie","root","get","key","node","children","child","values","set","value","k","Map","push","allPrefixes","results","i","compatToJongseong","skip","forEach","c","N","split","map","join","normalize","yongeons","eomis","_this","addYongeon","addEomi","undefined","addEomiUnit","dest","analyze","target","forms","form"],"mappings":"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"}