{"version":3,"file":"eomi.js","sources":["../src/conjugation.ts","../src/analyzer.ts"],"sourcesContent":["/* Utilities */\r\n\r\n/**\r\n * 초성, 중성, 종성에 해당하는 인덱스로 한글 음절을 조합한다.\r\n * @param x 초성 (0-18), 중성 (0-20), 종성 (0-27)으로 이루어진 정수 배열\r\n * @returns 조합된 한글 음절\r\n */\r\nfunction assembleSyllable(x: number[]): string {\r\n  const codepoint = x[0] * 588 + x[1] * 28 + x[2] + 0xac00;\r\n  return String.fromCharCode(codepoint);\r\n}\r\n\r\n/**\r\n * 문자열의 마지막 음절을 초성, 중성, 종성에 해당하는 인덱스로 분해한다.\r\n * @param x 분해하고자 하는 한글 음절로 끝나는 문자열.\r\n * @returns 초성 (0-18), 중성 (0-20), 종성 (0-27)으로 이루어진 정수 배열.\r\n */\r\nfunction disassembleSyllable(x: string): number[] {\r\n  const codepoint = x.charCodeAt(x.length - 1) - 0xac00;\r\n  const choseong = (codepoint / 588) | 0;\r\n  const jungseong = ((codepoint % 588) / 28) | 0;\r\n  const jongseong = codepoint % 28;\r\n  return [choseong, jungseong, jongseong];\r\n}\r\n\r\nconst BATCHIM_TABLE = \"ㄱㄲㄳㄴㄵㄶㄷㄹㄺㄻㄼㄽㄾㄿㅀㅁㅂㅄㅅㅆㅇㅈㅊㅋㅌㅍㅎ\";\r\nfunction getBatchim(x: string): string {\r\n  const idx = disassembleSyllable(x)[2];\r\n  return idx === 0 ? \"\" : BATCHIM_TABLE[idx - 1];\r\n}\r\n\r\nfunction startsWithSyllable(x: string): boolean {\r\n  return \"가\" <= x[0] && x[0] <= \"힣\";\r\n}\r\n\r\n/**\r\n * 두 한글 문자열을 결합한다.\r\n * @param x 결합할 앞 문자열.\r\n * @param y 결합할 뒤 문자열. 한글 음절로 시작하지 않을 수 있다.\r\n * @returns 결합된 문자열.\r\n */\r\nfunction concatHangeul(x: string, y: string): string {\r\n  const err = new Error(`Cannot concatenate '${x}' and '${y}'`);\r\n  if (!x || !y || startsWithSyllable(y)) return x + y;\r\n  const table = [\r\n    ,\r\n    ,\r\n    \"ㄱㄱ\",\r\n    \"ㄱㅅ\",\r\n    ,\r\n    \"ㄴㅈ\",\r\n    \"ㄴㅎ\",\r\n    ,\r\n    ,\r\n    \"ㄹㄱ\",\r\n    \"ㄹㅁ\",\r\n    \"ㄹㅂ\",\r\n    \"ㄹㅅ\",\r\n    \"ㄹㅌ\",\r\n    \"ㄹㅍ\",\r\n    \"ㄹㅎ\",\r\n    ,\r\n    ,\r\n    \"ㅂㅅ\",\r\n    ,\r\n    \"ㅅㅅ\",\r\n  ];\r\n  let newBatchim = table.indexOf(getBatchim(x) + y[0]);\r\n  if (newBatchim === -1) {\r\n    if (getBatchim(x)) throw err;\r\n    newBatchim = BATCHIM_TABLE.indexOf(y[0]) + 1;\r\n    if (newBatchim === 0) throw err;\r\n  }\r\n\r\n  let merged: number[] = disassembleSyllable(x);\r\n  merged[2] = newBatchim;\r\n  return x.slice(0, -1) + assembleSyllable(merged) + y.slice(1);\r\n}\r\n\r\n/* Main Classes */\r\n\r\n/** 한국어 용언 클래스. */\r\nclass Yongeon {\r\n  hada: string;\r\n  hae: string;\r\n  hani: string;\r\n  hamyeon: string;\r\n  batchim: string;\r\n\r\n  constructor(hada: string, hae?: string, hani?: string) {\r\n    this.hada = hada.slice(0, -1);\r\n    this.batchim = getBatchim(this.hada);\r\n\r\n    this.hae = hae || this.recoverHae();\r\n    this.hani = hani ? hani.slice(0, -1) : this.recoverHani();\r\n    this.hamyeon = this.batchim === \"ㄹ\" ? this.hada : this.hani;\r\n  }\r\n\r\n  /**\r\n   * 어미를 받아 활용합니다.\r\n   * 인수로는 어미 하나를 받거나 문자열 두 개를 받아 어미를 만듭니다.\r\n   */\r\n  _(eomi: Eomi | string, eomiAfterBatchim?: string): string {\r\n    if (!(eomi instanceof Eomi)) eomi = new Eomi(eomi, eomiAfterBatchim);\r\n    else if (eomiAfterBatchim != null)\r\n      throw Error(\r\n        \"If the first argument is a proper Eomi, only one argument should be given.\"\r\n      );\r\n\r\n    return eomi.after(this);\r\n  }\r\n\r\n  recoverHae(): string {\r\n    let jamos = disassembleSyllable(this.hada);\r\n    if (!this.batchim) {\r\n      if (jamos[1] === 0 || jamos[1] === 4) {\r\n        return this.hada; // ㅏ, ㅓ\r\n      } else if (jamos[1] === 18) {\r\n        jamos[1] = 4; // ㅡ -> ㅓ\r\n        return this.hada.slice(0, -1) + assembleSyllable(jamos);\r\n      }\r\n    }\r\n    return this.hada + (jamos[1] === 0 || jamos[1] === 8 ? \"아\" : \"어\"); // ㅏ, ㅗ\r\n  }\r\n\r\n  recoverHani(): string {\r\n    let jamos = disassembleSyllable(this.hada);\r\n    if (this.batchim === \"ㄹ\") {\r\n      // ㄹ 탈락\r\n      jamos[2] = 0;\r\n      return this.hada.slice(0, -1) + assembleSyllable(jamos);\r\n    }\r\n\r\n    const haeLast = this.hae.slice(-1);\r\n    if (\"아어\".indexOf(haeLast) !== -1) {\r\n      // 받침 있는 규칙 | ㄷ ㅅ 불규칙\r\n      return this.hae.slice(0, -1) + (this.batchim && \"으\");\r\n    } else if (\"와워\".indexOf(haeLast) !== -1) {\r\n      // ㅂ 불규칙\r\n      return this.hae.slice(0, -1) + \"우\";\r\n    } else if (this.batchim === \"ㅎ\") {\r\n      // ㅎ 불규칙\r\n      jamos[2] = 0;\r\n      return this.hada.slice(0, -1) + assembleSyllable(jamos);\r\n    }\r\n    return this.hada; // 받침 없는 규칙 | 르, 러, 우, 여 불규칙\r\n  }\r\n\r\n  valueOf(): string {\r\n    return this.hada + \"다\";\r\n  }\r\n}\r\n\r\nconst enum EomiType {\r\n  DIRECT = \"\",\r\n  A_EO = \"(아/어)\",\r\n  EU = \"(으)\",\r\n}\r\n\r\n/** 어미 활용을 구현한 클래스. */\r\nclass EomiUnit {\r\n  eomiType: EomiType;\r\n  body: string;\r\n  dropRieul: boolean;\r\n\r\n  constructor(eomi: string) {\r\n    const err = new Error(`Cannot parse given string ${eomi} to EomiUnit`);\r\n    if (eomi[0] === \"-\") eomi = eomi.slice(1);\r\n\r\n    const infTest = eomi.match(\r\n      /^[(]?([아-앟어-엏])(?:[/]([아-앟어-엏]))?[)]?(.*)$/\r\n    );\r\n    const seqTest = eomi.match(/^[(]?([으-읗])[)]?(.*)$/);\r\n    const batchimTest = eomi.match(/^([ㄱ-ㅎ].*)$/);\r\n\r\n    if (infTest !== null) {\r\n      const [, med1, med2, rest] = infTest;\r\n      if (med2 && getBatchim(med1) !== getBatchim(med2)) throw err;\r\n      this.body = getBatchim(med1) + rest;\r\n      this.eomiType = EomiType.A_EO;\r\n    } else if (seqTest !== null) {\r\n      const [, med, rest] = seqTest;\r\n      this.body = getBatchim(med) + rest;\r\n      this.eomiType = EomiType.EU;\r\n    } else if (batchimTest !== null) {\r\n      this.body = batchimTest[1];\r\n      this.eomiType = EomiType.EU;\r\n    } else {\r\n      this.body = eomi;\r\n      this.eomiType = EomiType.DIRECT;\r\n    }\r\n\r\n    if (startsWithSyllable(this.body)) {\r\n      const choseong = ((this.body.charCodeAt(0) - 0xac00) / 588) | 0;\r\n      this.dropRieul = [2, 9, 11].indexOf(choseong) !== -1; // [ㄴ, ㅅ, ㅇ]\r\n    } else {\r\n      this.dropRieul = \"ㄴㄹㅂ\".indexOf(this.body[0]) !== -1;\r\n    }\r\n  }\r\n\r\n  /** 용언을 받아 활용합니다. */\r\n  after(yongeon: Yongeon): string {\r\n    let stem: string = yongeon.hada;\r\n    if (this.eomiType === EomiType.A_EO) {\r\n      stem = yongeon.hae;\r\n    } else if (this.eomiType === EomiType.EU) {\r\n      stem = this.dropRieul ? yongeon.hani : yongeon.hamyeon;\r\n    } else if (this.dropRieul && yongeon.batchim === \"ㄹ\") {\r\n      stem = yongeon.hani;\r\n    }\r\n    return concatHangeul(stem, this.body);\r\n  }\r\n\r\n  valueOf(): string {\r\n    return \"-\" + this.eomiType + this.body;\r\n  }\r\n}\r\n\r\n/** 한국어 어미 클래스. */\r\nclass Eomi {\r\n  eomi: EomiUnit;\r\n  eomiAfterBatchim?: EomiUnit;\r\n  constructor(eomi: EomiUnit | string, eomiAfterBatchim?: EomiUnit | string) {\r\n    if (typeof eomi === \"string\") eomi = new EomiUnit(eomi);\r\n    if (typeof eomiAfterBatchim === \"string\")\r\n      eomiAfterBatchim = new EomiUnit(eomiAfterBatchim);\r\n    this.eomi = eomi;\r\n    this.eomiAfterBatchim = eomiAfterBatchim;\r\n  }\r\n\r\n  /** 용언을 받아 활용합니다. */\r\n  after(yongeon: Yongeon): string {\r\n    let eomi = this.eomi;\r\n    if (this.eomiAfterBatchim != null && yongeon.batchim) {\r\n      if (yongeon.batchim !== \"ㄹ\" || !eomi.dropRieul)\r\n        eomi = this.eomiAfterBatchim;\r\n    }\r\n    return eomi.after(yongeon);\r\n  }\r\n\r\n  valueOf(): string {\r\n    const after = this.eomiAfterBatchim;\r\n    return this.eomi + (after != null ? \"/\" + after : \"\");\r\n  }\r\n}\r\n\r\nexport { Yongeon, Eomi, EomiType };\r\n","import { Yongeon, Eomi, EomiType } from \"./conjugation\";\r\n\r\n/* Trie */\r\n\r\ntype TrieNode<T> = { values?: T[]; children?: Map<string, TrieNode<T>> };\r\nfunction _cloneNode<T>(node: TrieNode<T>): TrieNode<T> {\r\n  if (!node.children) return { values: node.values };\r\n  let children = new Map<string, TrieNode<T>>();\r\n  for (let [key, value] of node.children.entries()) {\r\n    children.set(key, _cloneNode(value));\r\n  }\r\n  return { values: node.values, children };\r\n}\r\n\r\nclass Trie<T> {\r\n  root: TrieNode<T>;\r\n  constructor() {\r\n    this.root = {};\r\n  }\r\n\r\n  clone(): Trie<T> {\r\n    let other = new Trie<T>();\r\n    other.root = _cloneNode(this.root);\r\n    return other;\r\n  }\r\n\r\n  get(key: string): T[] {\r\n    let node = this.root;\r\n    for (let k of key) {\r\n      if (!node.children) return [];\r\n      let child = node.children.get(k);\r\n      if (!child) return [];\r\n      node = child;\r\n    }\r\n    return node.values || [];\r\n  }\r\n\r\n  set(key: string, value: T): void {\r\n    let node = this.root;\r\n    for (let k of key) {\r\n      if (!node.children) node.children = new Map();\r\n      let child = node.children.get(k);\r\n      if (!child) {\r\n        child = {};\r\n        node.children.set(k, child);\r\n      }\r\n      node = child;\r\n    }\r\n    if (!node.values) node.values = [value];\r\n    else node.values.push(value);\r\n  }\r\n\r\n  /**\r\n   * Searches for all strings found in Trie that are the prefixes of `key`.\r\n   * @param key A string to search for prefixes\r\n   * @returns A list of pairs of values and the suffix remaining after the prefix.\r\n   */\r\n  allPrefixes(key: string): [T[], string][] {\r\n    let results: [T[], string][] = [];\r\n    let node = this.root;\r\n    for (let i = 0; i < key.length; i++) {\r\n      if (!node.children) break;\r\n      let child = node.children.get(key[i]);\r\n      if (!child) break;\r\n      if (child.values && child.values.length)\r\n        results.push([child.values, key.slice(i + 1)]);\r\n      node = child;\r\n    }\r\n    return results;\r\n  }\r\n}\r\n\r\n/* Analyzer */\r\n\r\n/**\r\n * 호환용 한글 자모 중 자음을 한글 자모 중 종성으로 변환합니다.\r\n * @param x 길이가 1인 문자열.\r\n * @returns 변환된 문자열. 해당되지 않으면 그대로 돌려받습니다.\r\n */\r\nfunction compatToJongseong(x: string) {\r\n  if (x < \"ㄱ\" || \"ㅎ\" < x) return x;\r\n  const skip = [\"ㄸ\", \"ㅃ\", \"ㅉ\"];\r\n  if (skip.indexOf(x[0]) !== -1) return x;\r\n\r\n  let codepoint = x.charCodeAt(0) - \"ㄱ\".charCodeAt(0);\r\n  skip.forEach((c) => (codepoint -= x > c ? 1 : 0));\r\n  return String.fromCharCode(codepoint + 0x11a8);\r\n}\r\n\r\n/**\r\n * 한글 문자열을 자모로 분리합니다.\r\n * @param x 한글 문자열. 음절 또는 자모로 구성됩니다.\r\n */\r\nfunction N(x: string) {\r\n  return x.split(\"\").map(compatToJongseong).join(\"\").normalize(\"NFD\");\r\n}\r\n\r\ntype YongeonForm = {\r\n  yongeon: Yongeon;\r\n  eomiType: EomiType | string; // workaround for const enum of another module\r\n  dropRieul?: boolean;\r\n};\r\ntype EomiRecord = { eomi: Eomi; eomiType: EomiType; dropRieul: boolean };\r\n\r\n/** 용언의 활용형을 어근과 어미로 분리하는 클래스. */\r\nclass Analyzer {\r\n  yongeons: Trie<YongeonForm>;\r\n  eomis: Map<string, EomiRecord[]>;\r\n\r\n  constructor(yongeons: Yongeon[], eomis: Eomi[]);\r\n  constructor(other: Analyzer);\r\n  constructor(yongeons: Yongeon[] | Analyzer, eomis: Eomi[] = []) {\r\n    if (yongeons instanceof Analyzer) {\r\n      this.yongeons = yongeons.yongeons.clone();\r\n      this.eomis = new Map(yongeons.eomis);\r\n    } else {\r\n      this.yongeons = new Trie();\r\n      yongeons.forEach((yongeon) => this.addYongeon(yongeon));\r\n\r\n      this.eomis = new Map();\r\n      eomis.forEach((eomi) => this.addEomi(eomi));\r\n    }\r\n  }\r\n\r\n  clone(): Analyzer {\r\n    return new Analyzer(this);\r\n  }\r\n\r\n  addYongeon(yongeon: Yongeon): void {\r\n    let dropRieul = yongeon.batchim === \"ㄹ\" ? false : undefined;\r\n    this.yongeons.set(N(yongeon.hada), {\r\n      yongeon,\r\n      eomiType: \"\",\r\n      dropRieul,\r\n    });\r\n    this.yongeons.set(N(yongeon.hae), { yongeon, eomiType: \"(아/어)\" });\r\n    this.yongeons.set(N(yongeon.hamyeon), {\r\n      yongeon,\r\n      eomiType: \"(으)\",\r\n      dropRieul,\r\n    });\r\n    if (yongeon.batchim === \"ㄹ\") {\r\n      this.yongeons.set(N(yongeon.hani), {\r\n        yongeon,\r\n        eomiType: \"\",\r\n        dropRieul: true,\r\n      });\r\n      this.yongeons.set(N(yongeon.hani), {\r\n        yongeon,\r\n        eomiType: \"(으)\",\r\n        dropRieul: true,\r\n      });\r\n    }\r\n  }\r\n\r\n  addEomi(eomi: Eomi): void {\r\n    this.addEomiUnit(N(eomi.eomi.body), {\r\n      eomi,\r\n      eomiType: eomi.eomi.eomiType,\r\n      dropRieul: eomi.eomi.dropRieul,\r\n    });\r\n    if (eomi.eomiAfterBatchim) {\r\n      this.addEomiUnit(N(eomi.eomiAfterBatchim.body), {\r\n        eomi,\r\n        eomiType: eomi.eomiAfterBatchim.eomiType,\r\n        dropRieul: eomi.eomiAfterBatchim.dropRieul,\r\n      });\r\n    }\r\n  }\r\n\r\n  addEomiUnit(key: string, value: EomiRecord): void {\r\n    let dest = this.eomis.get(key);\r\n    if (dest) dest.push(value);\r\n    else this.eomis.set(key, [value]);\r\n  }\r\n\r\n  /** 용언의 활용형을 분석해 어근 및 어미쌍의 배열을 내놓습니다. */\r\n  analyze(target: string): [Yongeon, Eomi][] {\r\n    let results: [Yongeon, Eomi][] = [];\r\n    for (let [forms, suffix] of this.yongeons.allPrefixes(N(target))) {\r\n      for (let { eomi, eomiType, dropRieul } of this.eomis.get(suffix) || []) {\r\n        for (let form of forms) {\r\n          if (eomiType !== form.eomiType) continue;\r\n          if (form.dropRieul != null && dropRieul !== form.dropRieul) continue;\r\n          results.push([form.yongeon, eomi]);\r\n        }\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n}\r\n\r\nexport { Analyzer };\r\n"],"names":["assembleSyllable","x","String","fromCharCode","disassembleSyllable","codepoint","charCodeAt","length","getBatchim","idx","startsWithSyllable","Yongeon","EomiType","hada","hae","hani","this","hamyeon","batchim","slice","recoverHae","recoverHani","_","eomi","eomiAfterBatchim","Eomi","Error","after","jamos","haeLast","indexOf","valueOf","EomiUnit","eomiType","body","dropRieul","err","infTest","match","seqTest","batchimTest","med1","med2","rest","A_EO","EU","DIRECT","choseong","yongeon","stem","y","newBatchim","merged","concatHangeul","_cloneNode","node","children","values","_step","Map","entries","_iterator","done","_step$value","value","set","Trie","root","clone","other","get","key","_step2","_iterator2","_createForOfIteratorHelperLoose","child","_step3","_iterator3","k","push","allPrefixes","results","i","compatToJongseong","skip","forEach","c","N","split","map","join","normalize","Analyzer","yongeons","eomis","_this","addYongeon","addEomi","undefined","addEomiUnit","dest","analyze","target","_step4","_iterator4","_step5","_step4$value","forms","_iterator5","_step6","_step5$value","_iterator6","form"],"mappings":"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"}