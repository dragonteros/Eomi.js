{"version":3,"file":"eomi.modern.js","sources":["../src/conjugation.ts","../src/analyzer.ts"],"sourcesContent":["/* Utilities */\n\n/**\n * 초성, 중성, 종성에 해당하는 인덱스로 한글 음절을 조합한다.\n * @param x 초성 (0-18), 중성 (0-20), 종성 (0-27)으로 이루어진 정수 배열\n * @returns 조합된 한글 음절\n */\nfunction assembleSyllable(x: number[]): string {\n  const codepoint = x[0] * 588 + x[1] * 28 + x[2] + 0xac00;\n  return String.fromCharCode(codepoint);\n}\n\n/**\n * 문자열의 마지막 음절을 초성, 중성, 종성에 해당하는 인덱스로 분해한다.\n * @param x 분해하고자 하는 한글 음절로 끝나는 문자열.\n * @returns 초성 (0-18), 중성 (0-20), 종성 (0-27)으로 이루어진 정수 배열.\n */\nfunction disassembleSyllable(x: string): number[] {\n  const codepoint = x.charCodeAt(x.length - 1) - 0xac00;\n  const choseong = (codepoint / 588) | 0;\n  const jungseong = ((codepoint % 588) / 28) | 0;\n  const jongseong = codepoint % 28;\n  return [choseong, jungseong, jongseong];\n}\n\nconst BATCHIM_TABLE = \"ㄱㄲㄳㄴㄵㄶㄷㄹㄺㄻㄼㄽㄾㄿㅀㅁㅂㅄㅅㅆㅇㅈㅊㅋㅌㅍㅎ\";\nfunction getBatchim(x: string): string {\n  const idx = disassembleSyllable(x)[2];\n  return idx === 0 ? \"\" : BATCHIM_TABLE[idx - 1];\n}\n\nfunction startsWithSyllable(x: string): boolean {\n  return \"가\" <= x[0] && x[0] <= \"힣\";\n}\n\n/**\n * 두 한글 문자열을 결합한다.\n * @param x 결합할 앞 문자열.\n * @param y 결합할 뒤 문자열. 한글 음절로 시작하지 않을 수 있다.\n * @returns 결합된 문자열.\n */\nfunction concatHangeul(x: string, y: string): string {\n  const err = new Error(`Cannot concatenate '${x}' and '${y}'`);\n  if (!x || !y || startsWithSyllable(y)) return x + y;\n  const table = [\n    ,\n    ,\n    \"ㄱㄱ\",\n    \"ㄱㅅ\",\n    ,\n    \"ㄴㅈ\",\n    \"ㄴㅎ\",\n    ,\n    ,\n    \"ㄹㄱ\",\n    \"ㄹㅁ\",\n    \"ㄹㅂ\",\n    \"ㄹㅅ\",\n    \"ㄹㅌ\",\n    \"ㄹㅍ\",\n    \"ㄹㅎ\",\n    ,\n    ,\n    \"ㅂㅅ\",\n    ,\n    \"ㅅㅅ\",\n  ];\n  let newBatchim = table.indexOf(getBatchim(x) + y[0]);\n  if (newBatchim === -1) {\n    if (getBatchim(x)) throw err;\n    newBatchim = BATCHIM_TABLE.indexOf(y[0]) + 1;\n    if (newBatchim === 0) throw err;\n  }\n\n  let merged: number[] = disassembleSyllable(x);\n  merged[2] = newBatchim;\n  return x.slice(0, -1) + assembleSyllable(merged) + y.slice(1);\n}\n\n/* Main Classes */\n\n/** 한국어 용언 클래스. */\nclass Yongeon {\n  hada: string;\n  hae: string;\n  hani: string;\n  hamyeon: string;\n  batchim: string;\n\n  constructor(hada: string, hae?: string, hani?: string) {\n    this.hada = hada.slice(0, -1);\n    this.batchim = getBatchim(this.hada);\n\n    this.hae = hae || this.recoverHae();\n    this.hani = hani ? hani.slice(0, -1) : this.recoverHani();\n    this.hamyeon = this.batchim === \"ㄹ\" ? this.hada : this.hani;\n  }\n\n  /**\n   * 어미를 받아 활용합니다.\n   * 인수로는 어미 하나를 받거나 문자열 두 개를 받아 어미를 만듭니다.\n   */\n  _(eomi: Eomi | string, eomiAfterBatchim?: string): string {\n    if (!(eomi instanceof Eomi)) eomi = new Eomi(eomi, eomiAfterBatchim);\n    else if (eomiAfterBatchim != null)\n      throw Error(\n        \"If the first argument is a proper Eomi, only one argument should be given.\"\n      );\n\n    return eomi.after(this);\n  }\n\n  recoverHae(): string {\n    let jamos = disassembleSyllable(this.hada);\n    if (!this.batchim) {\n      if (jamos[1] === 0 || jamos[1] === 4) {\n        return this.hada; // ㅏ, ㅓ\n      } else if (jamos[1] === 18) {\n        jamos[1] = 4; // ㅡ -> ㅓ\n        return this.hada.slice(0, -1) + assembleSyllable(jamos);\n      }\n    }\n    return this.hada + (jamos[1] === 0 || jamos[1] === 8 ? \"아\" : \"어\"); // ㅏ, ㅗ\n  }\n\n  recoverHani(): string {\n    let jamos = disassembleSyllable(this.hada);\n    if (this.batchim === \"ㄹ\") {\n      // ㄹ 탈락\n      jamos[2] = 0;\n      return this.hada.slice(0, -1) + assembleSyllable(jamos);\n    }\n\n    const haeLast = this.hae.slice(-1);\n    if (\"아어\".indexOf(haeLast) !== -1) {\n      // 받침 있는 규칙 | ㄷ ㅅ 불규칙\n      return this.hae.slice(0, -1) + (this.batchim && \"으\");\n    } else if (\"와워\".indexOf(haeLast) !== -1) {\n      // ㅂ 불규칙\n      return this.hae.slice(0, -1) + \"우\";\n    } else if (this.batchim === \"ㅎ\") {\n      // ㅎ 불규칙\n      jamos[2] = 0;\n      return this.hada.slice(0, -1) + assembleSyllable(jamos);\n    }\n    return this.hada; // 받침 없는 규칙 | 르, 러, 우, 여 불규칙\n  }\n\n  valueOf(): string {\n    return this.hada + \"다\";\n  }\n}\n\nconst enum EomiType {\n  DIRECT = \"\",\n  A_EO = \"(아/어)\",\n  EU = \"(으)\",\n}\n\n/** 어미 활용을 구현한 클래스. */\nclass EomiUnit {\n  eomiType: EomiType;\n  body: string;\n  dropRieul: boolean;\n\n  constructor(eomi: string) {\n    const err = new Error(`Cannot parse given string ${eomi} to EomiUnit`);\n    if (eomi[0] === \"-\") eomi = eomi.slice(1);\n\n    const infTest = eomi.match(\n      /^[(]?([아-앟어-엏])(?:[/]([아-앟어-엏]))?[)]?(.*)$/\n    );\n    const seqTest = eomi.match(/^[(]?([으-읗])[)]?(.*)$/);\n    const batchimTest = eomi.match(/^([ㄱ-ㅎ].*)$/);\n\n    if (infTest !== null) {\n      const [, med1, med2, rest] = infTest;\n      if (med2 && getBatchim(med1) !== getBatchim(med2)) throw err;\n      this.body = getBatchim(med1) + rest;\n      this.eomiType = EomiType.A_EO;\n    } else if (seqTest !== null) {\n      const [, med, rest] = seqTest;\n      this.body = getBatchim(med) + rest;\n      this.eomiType = EomiType.EU;\n    } else if (batchimTest !== null) {\n      this.body = batchimTest[1];\n      this.eomiType = EomiType.EU;\n    } else {\n      this.body = eomi;\n      this.eomiType = EomiType.DIRECT;\n    }\n\n    if (startsWithSyllable(this.body)) {\n      const choseong = ((this.body.charCodeAt(0) - 0xac00) / 588) | 0;\n      this.dropRieul = [2, 9, 11].indexOf(choseong) !== -1; // [ㄴ, ㅅ, ㅇ]\n    } else {\n      this.dropRieul = \"ㄴㄹㅂ\".indexOf(this.body[0]) !== -1;\n    }\n  }\n\n  /** 용언을 받아 활용합니다. */\n  after(yongeon: Yongeon): string {\n    let stem: string = yongeon.hada;\n    if (this.eomiType === EomiType.A_EO) {\n      stem = yongeon.hae;\n    } else if (this.eomiType === EomiType.EU) {\n      stem = this.dropRieul ? yongeon.hani : yongeon.hamyeon;\n    } else if (this.dropRieul && yongeon.batchim === \"ㄹ\") {\n      stem = yongeon.hani;\n    }\n    return concatHangeul(stem, this.body);\n  }\n\n  valueOf(): string {\n    return \"-\" + this.eomiType + this.body;\n  }\n}\n\n/** 한국어 어미 클래스. */\nclass Eomi {\n  eomi: EomiUnit;\n  eomiAfterBatchim?: EomiUnit;\n  constructor(eomi: EomiUnit | string, eomiAfterBatchim?: EomiUnit | string) {\n    if (typeof eomi === \"string\") eomi = new EomiUnit(eomi);\n    if (typeof eomiAfterBatchim === \"string\")\n      eomiAfterBatchim = new EomiUnit(eomiAfterBatchim);\n    this.eomi = eomi;\n    this.eomiAfterBatchim = eomiAfterBatchim;\n  }\n\n  /** 용언을 받아 활용합니다. */\n  after(yongeon: Yongeon): string {\n    let eomi = this.eomi;\n    if (this.eomiAfterBatchim != null && yongeon.batchim) {\n      if (yongeon.batchim !== \"ㄹ\" || !eomi.dropRieul)\n        eomi = this.eomiAfterBatchim;\n    }\n    return eomi.after(yongeon);\n  }\n\n  valueOf(): string {\n    const after = this.eomiAfterBatchim;\n    return this.eomi + (after != null ? \"/\" + after : \"\");\n  }\n}\n\nexport { Yongeon, Eomi, EomiType };\n","import { Yongeon, Eomi, EomiType } from \"./conjugation\";\n\n/* Trie */\n\ntype TrieNode<T> = { values?: T[]; children?: Map<string, TrieNode<T>> };\n\nclass Trie<T> {\n  root: TrieNode<T>;\n  constructor() {\n    this.root = {};\n  }\n\n  get(key: string): T[] {\n    let node = this.root;\n    for (let k of key) {\n      if (!node.children) return []\n      let child = node.children.get(k);\n      if (!child) return [];\n      node = child;\n    }\n    return node.values || [];\n  }\n\n  set(key: string, value: T): void {\n    let node = this.root;\n    for (let k of key) {\n      if (!node.children) node.children = new Map();\n      let child = node.children.get(k);\n      if (!child) {\n        child = {};\n        node.children.set(k, child);\n      }\n      node = child;\n    }\n    if (!node.values) node.values = [value];\n    else node.values.push(value);\n  }\n\n  /**\n   * Searches for all strings found in Trie that are the prefixes of `key`.\n   * @param key A string to search for prefixes\n   * @returns A list of pairs of values and the suffix remaining after the prefix.\n   */\n  allPrefixes(key: string): [T[], string][] {\n    let results: [T[], string][] = [];\n    let node = this.root;\n    for (let i = 0; i < key.length; i++) {\n      if (!node.children) break\n      let child = node.children.get(key[i]);\n      if (!child) break;\n      if (child.values && child.values.length) results.push([child.values, key.slice(i + 1)]);\n      node = child;\n    }\n    return results;\n  }\n}\n\n/* Analyzer */\n\n/**\n * 호환용 한글 자모 중 자음을 한글 자모 중 종성으로 변환합니다.\n * @param x 길이가 1인 문자열.\n * @returns 변환된 문자열. 해당되지 않으면 그대로 돌려받습니다.\n */\nfunction compatToJongseong(x: string) {\n  if (x < \"ㄱ\" || \"ㅎ\" < x) return x;\n  const skip = [\"ㄸ\", \"ㅃ\", \"ㅉ\"];\n  if (skip.indexOf(x[0]) !== -1) return x;\n\n  let codepoint = x.charCodeAt(0) - \"ㄱ\".charCodeAt(0);\n  skip.forEach((c) => (codepoint -= x > c ? 1 : 0));\n  return String.fromCharCode(codepoint + 0x11a8);\n}\n\n/**\n * 한글 문자열을 자모로 분리합니다.\n * @param x 한글 문자열. 음절 또는 자모로 구성됩니다.\n */\nfunction N(x: string) {\n  return x.split(\"\").map(compatToJongseong).join(\"\").normalize(\"NFD\");\n}\n\ntype YongeonForm = {\n  yongeon: Yongeon;\n  eomiType: EomiType | string;\n  dropRieul?: boolean;\n};\ntype EomiRecord = { eomi: Eomi; eomiType: EomiType; dropRieul: boolean };\n\n/** 용언의 활용형을 어근과 어미로 분리하는 클래스. */\nclass Analyzer {\n  yongeons: Trie<YongeonForm>;\n  eomis: Map<string, EomiRecord[]>;\n  constructor(yongeons: Yongeon[], eomis: Eomi[]) {\n    this.yongeons = new Trie();\n    yongeons.forEach((yongeon) => this.addYongeon(yongeon));\n\n    this.eomis = new Map();\n    eomis.forEach((eomi) => this.addEomi(eomi));\n  }\n\n  addYongeon(yongeon: Yongeon): void {\n    let dropRieul = yongeon.batchim === \"ㄹ\" ? false : undefined;\n    this.yongeons.set(N(yongeon.hada), {\n      yongeon,\n      eomiType: \"\",\n      dropRieul,\n    });\n    this.yongeons.set(N(yongeon.hae), { yongeon, eomiType: \"(아/어)\" });\n    this.yongeons.set(N(yongeon.hamyeon), {\n      yongeon,\n      eomiType: \"(으)\",\n      dropRieul,\n    });\n    if (yongeon.batchim === \"ㄹ\") {\n      this.yongeons.set(N(yongeon.hani), {\n        yongeon,\n        eomiType: \"\",\n        dropRieul: true,\n      });\n      this.yongeons.set(N(yongeon.hani), {\n        yongeon,\n        eomiType: \"(으)\",\n        dropRieul: true,\n      });\n    }\n  }\n\n  addEomi(eomi: Eomi): void {\n    this.addEomiUnit(N(eomi.eomi.body), {\n      eomi,\n      eomiType: eomi.eomi.eomiType,\n      dropRieul: eomi.eomi.dropRieul,\n    });\n    if (eomi.eomiAfterBatchim) {\n      this.addEomiUnit(N(eomi.eomiAfterBatchim.body), {\n        eomi,\n        eomiType: eomi.eomiAfterBatchim.eomiType,\n        dropRieul: eomi.eomiAfterBatchim.dropRieul,\n      });\n    }\n  }\n\n  addEomiUnit(key: string, value: EomiRecord): void {\n    let dest = this.eomis.get(key);\n    if (dest) dest.push(value);\n    else this.eomis.set(key, [value]);\n  }\n\n  /** 용언의 활용형을 분석해 어근 및 어미쌍의 배열을 내놓습니다. */\n  analyze(target: string): [Yongeon, Eomi][] {\n    let results: [Yongeon, Eomi][] = [];\n    for (let [forms, suffix] of this.yongeons.allPrefixes(N(target))) {\n      for (let { eomi, eomiType, dropRieul } of this.eomis.get(suffix) || []) {\n        for (let form of forms) {\n          if (eomiType !== form.eomiType) continue;\n          if (form.dropRieul != null && dropRieul !== form.dropRieul) continue;\n          results.push([form.yongeon, eomi]);\n        }\n      }\n    }\n    return results;\n  }\n}\n\nexport { Analyzer };\n"],"names":["assembleSyllable","x","String","fromCharCode","disassembleSyllable","codepoint","charCodeAt","length","getBatchim","idx","startsWithSyllable","Yongeon","constructor","hada","hae","hani","this","slice","batchim","recoverHae","recoverHani","hamyeon","_","eomi","eomiAfterBatchim","Eomi","Error","after","jamos","haeLast","indexOf","valueOf","EomiType","EomiUnit","err","infTest","match","seqTest","batchimTest","med1","med2","rest","body","eomiType","A_EO","med","EU","DIRECT","choseong","dropRieul","yongeon","stem","y","newBatchim","merged","concatHangeul","Trie","root","get","key","node","k","children","child","values","set","value","Map","push","allPrefixes","results","i","compatToJongseong","skip","forEach","c","N","split","map","join","normalize","Analyzer","yongeons","eomis","addYongeon","addEomi","undefined","addEomiUnit","dest","analyze","target","forms","suffix","form"],"mappings":"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"}